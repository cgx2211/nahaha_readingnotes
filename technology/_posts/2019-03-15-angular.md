---
layout: post
title: Angular 1.X
---
### angular表达式(Expressions)
  One-time binding一次性绑定  
  {% raw %}
  ```html
  <div ng-controller="EventController">
    <button ng-click="clickMe($event)">Click Me</button>
    <p id="one-time-binding-example">One time binding: {{::name}}</p>
    <p id="normal-binding-example">Normal binding: {{name}}</p>
  </div>
  ```
  {% endraw %}
  表达式双花括号中连续的冒号代表一次性绑定，值渲染一次之后将不再变动。  
  一次性绑定可以释放多余资源，减少需监听的表达式，提升整体效率。  
  只要在一次循环(digest cycle)结束时，表达式的值不为undefined，随之则注销掉相关的监听。否则，angular会继续监听该表达式  
  针对不会变动的值均可采用一次性绑定的方式处理
  自定义指令中的参数：
  {% raw %}
  ```html
  <div some-directive name="::myName" color="My color is {{::myColor}}"></div>
  ```
  {% endraw %}
  默认指令中的表达式
  {% raw %}
  ```html
  <ul>
    <li ng-repeat="item in ::items | orderBy:'name'">{{item.name}};</li>
  </ul>
  ```
  {% endraw %}

### 插值与数据绑定(Interpolation and data-binding)
  插值不仅可以用在标签内，也可用在指令的表达式中
  {% raw %}
  ```html
  <a ng-href="img/{{username}}.jpg">Hello {{username}}!</a>
  ```
  {% endraw %}
  编译过程中，$interpolate服务发现有插值符（双大括号），则会在插值符处添加interpolateDirective，并注册监听将插值纳入常规循环
  插值的计算
  - undefined 或 null视作""
  - 插值为非数字、日期、数组的对象，调用自定义的toString方法
  - 以上都不是，调用JSON.stringify
  插值不能直接绑定布尔型，HTML规范与浏览器行为会认为布尔值有为true，无为false。  
  取而代之用ng-开头的angular指定，如ng-disabled  
  自定义属性，ng-attr-开头。驼峰命名，用下划线区分：ng-attr-view_box  
  目前已知有部分属性在部分标签上有异常，可用ngAttr替代
  - &lt;select&gt;标签的size属性[issue1619](https://github.com/angular/angular.js/issues/1619)
  - &lt;textarea&gt;标签的placeholder属性，在IE10/11下不正常[issue5025](https://github.com/angular/angular.js/issues/5025)
  - &lt;button&gt;标签的type属性，在IE11下不正常[issue14117](https://github.com/angular/angular.js/issues/14117)
  - &lt;progress&gt;标签的value属性，在IE11下不正常[issue7218](https://github.com/angular/angular.js/issues/Embedding7218)  
  应尽量避免在表达式中使用插值符，插值符的值尽量不更改。  
  为什么？  
  - 降低复杂度
  - 无法保证在任何地方插值符都能正常运作，插值本身就是插件。在调用顺序上，其他插件优先可能导致取不到值
  - 效率低，越多插值，越多监听
  - 由于不推荐使用，我们并未测试过。如果angularJS版本升级，可能要爆炸

### 过滤器(filters)
  angularJS自带过滤器，默认API为$filterProvider。  

#### html模板中使用
  常规：  
  {% raw %}
  ```javascript
  {{ expression | filter }}
  ```
  {% endraw %}
  链式调用，筛了又筛  
  {% raw %}
  ```javascript
  {{ expression | filter1 | filter2 | ... }}
  ```
  {% endraw %}
  包含参数
  {% raw %}
  ```javascript
  {{ expression | filter:argument1:argument2:... }}
  ```  
  {% endraw %}
#### 调用时间
  Html模板中，filter只有在值变化的时候才触发，这比每次循环都触发效率高。
  两个例外  
  - 上述通常情况只在基本类型数据应用filter时有效，当filter用在对象上时，每次循环都会触发，深度监听太耗费资源了
  - $stateful标记的filter在每次循环的时候都会触发

#### 在controller，service，directive中使用
  调用格式&lt;filterName&gt;Filter，筛选数字就为：numberFilter。  
  调用方式如下，第一个参数为备选项，第二个参数为筛选项。  
  {% raw %}
  ```javascript
  this.filteredArray = filterFilter(this.array, 'a');
  ```  
  {% endraw %}
#### 自定义filter
  自定义filter非常简单，用filter工厂函数即可，内部使用的是filterProvider。命名要符合规范，可驼峰，可下划线，不能有其他特殊字符  
  自定义filter必须为纯函数，不应影响外部变量。  
  $stateful标记的filter可用，但效率很低。  
#### 状态化filter
  强烈建议不使用状态化的filter。可通过将变动部分分离出来，将之转换为静态的filter。

### 表单(Forms)
  客户端的表单验证，可极大的提升用户体验。

#### CSS样式
  ngModel会添加如下样式：
  - ng-valid: 值通过校验
  - ng-invalid: 值未通过校验
  - ng-valid-[key]: $setValidity添加的有效值
  - ng-invalid-[key]: $setValidity添加的无效值
  - ng-pristine: 未交互的
  - ng-dirty: 已交互的
  - ng-touched: 失去焦点的
  - ng-untouched: 未失去焦点的
  - ng-pending: 所有未满足的$asyncValidators

#### 绑定表单与控制器
  表单就是FormController的实例，通过表单name属性，可在scope中随意取用。  
  同样，每个input控件，只要应用了ngModel指令，都拥有NgModelController的实例。对应的name属性即可从表单实例中取到对应的值  
#### 自定义触发器
  用户输入与表单验证默认在用户输入时即时触发，通过修改ng-model-options属性，可以改变触发器的时机。  
  ng-model-options="{ updateOn: 'blur' }"可在失去焦点的时候触发。  
  ng-model-options="{ updateOn: 'mousedown blur' }"增加更多的事件。  
  因此可以在保留默认事件的情况下，新增事件，比如ng-model-options="{ updateOn: 'default blur' }"。  
#### 延迟触发
  设置ng-model-options="{ debounce: 500 }"属性(单位毫秒)，可以延迟交互触发。同时作用于各类表单校验。  
  debounce值可以为对象，用于配置更多的事件：ng-model-options="{ updateOn: 'default blur', debounce: { default: 500, blur: 0 } }"  
  ng-model-options可以向下继承直至改写。  
#### 自定义表单校验
  angular自带基本校验，通过自定义指令，可以在$validators对象中增加校验方法。  
  $validators中任何的方法都带有两个参数modelValue与viewValue，当控件的值变动之后，angular会通过$setValidity调用对应方法返回true与false。  
  校验在$parsers与$formatters两步都成功之后触发，校验失败的key会存储在ngModelController.$error之中。  
  校验支持异步，通过$q.defer()返回resolved与rejected。
  异步等待的过程中，从ngModelController.$pending中，可通过key取到该校验的状态。  
  自定义整型判断指令  
  {% raw %}
  ```javascript
  var INTEGER_REGEXP = /^-?\d+$/;
  app.directive('integer', function() {
    return {
      require: 'ngModel',
      link: function(scope, elm, attrs, ctrl) {
        ctrl.$validators.integer = function(modelValue, viewValue) {
          if (ctrl.$isEmpty(modelValue)) {
            // consider empty models to be valid
            return true;
          }

          if (INTEGER_REGEXP.test(viewValue)) {
            // it is valid
            return true;
          }

          // it is invalid
          return false;
        };
      }
    };
  });
  ```  
  {% endraw %}
  自定义异步校验  
  {% raw %}
  ```javascript
  app.directive('username', function($q, $timeout) {
    return {
      require: 'ngModel',
      link: function(scope, elm, attrs, ctrl) {
        var usernames = ['Jim', 'John', 'Jill', 'Jackie'];
        ctrl.$asyncValidators.username = function(modelValue, viewValue) {
          if (ctrl.$isEmpty(modelValue)) {
            // 没有值步校验
            return $q.resolve();
          }

          var def = $q.defer();
          $timeout(function() {
            // 模拟一次异步回调
            if (usernames.indexOf(modelValue) === -1) {
              // 值有效
              def.resolve();
            } else {
              // 值无效
              def.reject();
            }
          }, 2000);
          return def.promise;
        };
      }
    };
  });
  ```
  {% endraw %}
#### 复写已有的校验
  复写默认的email校验
  {% raw %}
  ```javascript
  app.directive('overwriteEmail', function() {
    var EMAIL_REGEXP = /^[a-z0-9!#$%&'*+/=?^_`{|}~.-]+@example\.com$/i;

    return {
      require: '?ngModel',
      link: function(scope, elm, attrs, ctrl) {
        // only apply the validator if ngModel is present and AngularJS has added the email validator
        if (ctrl && ctrl.$validators.email) {

          // this will overwrite the default AngularJS email validator
          ctrl.$validators.email = function(modelValue) {
            return ctrl.$isEmpty(modelValue) || EMAIL_REGEXP.test(modelValue);
          };
        }
      }
    };
  });
  ```
  {% endraw %}
  对应的Html：
  {% raw %}
  ```html
  <input type="email" ng-model="myEmail" overwrite-email name="overwrittenEmail" />
  ```
  {% endraw %}
#### 用ngModel自定义表格控件
  通过ngModel自定义控件并实现双向绑定。
  - 实现$render方法
  - 调用$setViewValue方法

### 自定义指令
#### 指令是啥
  DOM元素上的标记，诸如属性，元素名称甚至CSS样式。当angular进入html编译(compiler)阶段，就会在对应的DOM元素上新增事件，甚至改变整个DOM元素。  
#### 匹配指令
  元素指令匹配与元素选择器匹配的原理类似。元素中只要声明了相关指令，即可匹配。
#### 常规使用
  由于HTML不区分大小写，因此在使用指令的时候，用符号分隔开。包括冒号，下划线，短横线。同时属性若有data-与x-的开头，会被忽略。  
  推荐使用短横线的方式。  
#### 指令类型
  指令可匹配名称(E)，属性(A)，样式名(C)，注释(M)。
  {% raw %}
  ```html
  <my-dir></my-dir>
  <span my-dir="exp"></span>
  <!-- directive: my-dir exp -->
  <span class="my-dir: exp;"></span>
  ```
  {% endraw %}
  建议：尽量使用E与A。注释型指令主要用于一些特殊位置，例如table中，DOM API有限制，无法创建指令。  
  AngularJS1.2版本后引入了ng-repeat-start与ng-repeat-end作为解决方案。  
#### 创建指令
  与创建控制器，服务类似，调用module.directive即可注册指令。之后工厂函数的常规名称作为指令名称。  
  工厂函数需返回包含各类选项的对象。编译阶段将按选项执行。  
  编译阶段首次匹配到了指令就会调用工厂函数。指令命名建议添加非ng-的前缀，以免与默认标签、angular自带的指令冲突。  
  指令中templateUrl属性也可是方法，包含两个参数：当前的DOM元素与元素上的attr属性。  
  全新的组件指令，就用在DOM元素上。给已存在的元素新增功能，那么就用属性。  
#### 独立scope
  指令中独立的scope不继承其他的scope
#### 创建可操作DOM的指令
  指令操作DOM对象均通过link选项在DOM上注册监听，并更新DOM，指令逻辑也包含其中。模板渲染完成后即刻调用link函数。  
  Link为包含以下参数的函数：  
  - scope angularJS的scope对象
  - element 指令匹配到的元素
  - attrs 包含初始属性名与属性值的对象
  - controller 指令所需的控制器实例(可多个)，或者自身的控制器(如果有)。
  - transcludeFn is a transclude linking function pre-bound to the correct transclusion scope。  
  指令与控制器相似，通过依赖可以调用诸如$interval等方式。  
  指令的DOM节点，经过angularJS编译阶段之后。一旦销毁，即会广播$destroy，指令中element.on('$destroy',...)方法捕捉到之后，即可做后续操作。  
  比如清理定时器，多余的监听事件等，以免造成溢出。  
  scope销毁之后也会广播$destroy，清理相关监听、事件是个好习惯。
#### 包裹其他元素的指令
  指令中的模板，还可以包含其他的元素。需要启用transclude属性。  
  transclude有什么作用？transclude使得指令中的内容可以访问外部的scope。  
  指令中配置scope: {'close': '&onClose'}，通过&符号可以调用外部scope的方法。  
#### 创建指令新增事件监听
  指令的link方法中，element参数可以直接element.on的方式来注册监听，并操作DOM元素。  
#### 指令之间的相互通讯
  指令中require选项可有前缀。
  - ^^告知angular在父级找寻对应控制器
  - ^告知angular在本指令与父级找寻对应控制器
  - 无前缀angular只在本指令中找寻控制器
  require中依赖的控制器，在link函数中第四个参数可取到，若依赖了多个，参数则为一个数组  
  {% raw %}
  ```javascript
  angular.module('docsTabsExample', [])
  .directive('myPane', function() {
    return {
      //这里依赖两个其他指令
      require: ['^^myTabs', 'ngModel'],
      restrict: 'E',
      transclude: true,
      scope: {
        title: '@'
      },
      link: function(scope, element, attrs, controllers) {
        //第四个参数controllers为数组，分别包含两个控制器
        var tabsCtrl = controllers[0],
            modelCtrl = controllers[1];
        tabsCtrl.addPane(scope);
      },
      templateUrl: 'my-pane.html'
    };
  });
  ```
  {% endraw %}
