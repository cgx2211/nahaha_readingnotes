---
layout: post
title: webpack
permalink: /technology/webpack
---
# 学习webpack打包工具
## webpack核心概念
Entry 入口文件，构建其内部 依赖图(dependency graph) 的开始  
Output 输出文件，告诉 webpack 在哪里输出它所创建的 bundle，以及如何命名这些文件  
loader 让 webpack 能够去处理那些非 JavaScript 文件（webpack 自身只理解 JavaScript）。loader 可以将所有类型的文件转换为 webpack 能够处理的有效模块，然后你就可以利用 webpack 的打包能力，对它们进行处理。  
plugin 插件的范围包括，从打包优化和压缩，一直到重新定义环境中的变量  
Mode 模式，通过选择 development, production 或 none 之中的一个，来设置 mode 参数，你可以启用 webpack 内置在相应环境下的优化。其默认值为 production  
Browser Compatibility 浏览器兼容性，想要支持旧版本浏览器，在使用这些表达式之前，还需要 提前加载 polyfill  
Enviroment 运行webpack的node版本  

## 开发/测试/生产环境有什么不同？  
## 需要做哪些webpack配置？

开发/测试环境
- 文件依赖方式-直接引入
- 热更新
- 文件模块中的依赖路径信息
- fast-refresh：组件快速刷新替换
- sourceMap

生产环境
- 模块合并压缩
- 文件依赖方式，压缩代码后添加文件后缀后引入
- html压缩并注入文件
- PWA 渐进式网络开发应用程序的相关配置
- 打包后的文件大小分析报告

### 文件依赖方式
开发/测试环境直接依赖文件，生产环境压缩后依赖文件
css文件相关依赖配置
```js
isEnvDevelopment && require.resolve('style-loader'),
isEnvProduction && {
  loader: MiniCssExtractPlugin.loader,
  options: paths.publicUrlOrPath.startsWith('.')
    ? { publicPath: '../../' }
    : {},
},
```
输出文件依赖路径和命名配置
```js
output: {
  path: isEnvProduction ? paths.appBuild : undefined,
  pathinfo: isEnvDevelopment,
  filename: isEnvProduction
    ? 'static/js/[name].[contenthash:8].js'
    : isEnvDevelopment && 'static/js/bundle.js',
  chunkFilename: isEnvProduction
    ? 'static/js/[name].[contenthash:8].chunk.js'
    : isEnvDevelopment && 'static/js/[name].chunk.js',
  devtoolModuleFilenameTemplate: isEnvProduction
    ? info =>
        path
          .relative(paths.appSrc, info.absoluteResourcePath)
          .replace(/\\/g, '/')
    : isEnvDevelopment &&
      (info => path.resolve(info.absoluteResourcePath).replace(/\\/g, '/')),
},
```
模块压缩合并配置
```js
// loaders
{
  test: /\.(js|mjs|jsx|ts|tsx)$/,
  include: paths.appSrc,
  loader: require.resolve('babel-loader'),
  options: {
    customize: require.resolve(
      'babel-preset-react-app/webpack-overrides'
    ),
    plugins: [
      [
        require.resolve('babel-plugin-named-asset-import'),
        {
          loaderMap: {
            svg: {
              ReactComponent:
                '@svgr/webpack?-svgo,+titleProp,+ref![path]',
            },
          },
        },
      ].filter(Boolean),
    ],
    cacheDirectory: true,
    cacheCompression: false,
    compact: isEnvProduction,
  },
},
// plugin
isEnvProduction &&
new MiniCssExtractPlugin({
  // Options similar to the same options in webpackOptions.output
  // both options are optional
  filename: 'static/css/[name].[contenthash:8].css',
  chunkFilename: 'static/css/[name].[contenthash:8].chunk.css',
}),
```
### sourceMap
由于开发/测试环境对性能没有要求，且需要代码的sourceMap方便定位问题，而生产环境对性能有要求，sourceMap会加大访问流量和页面加载速度，所以需要配置webpack判断：
首先获取node环境中的变量
```js
// webpack.config.js
// Source maps are resource heavy and can cause out of memory issue for large source files.
const shouldUseSourceMap = process.env.GENERATE_SOURCEMAP !== 'false';
```
在返回的webpack json文件中配置devtool属性，控制是否启用sourceMap
```js
// 控制是否生成sourceMap
devtool: isEnvProduction
  ? shouldUseSourceMap
  ? 'source-map'
  : false
  : isEnvDevelopment && 'cheap-module-source-map',
```
编写公共方法，处理css/scss/less的loaders是否启用sourceMap  
```js
// common function to get style loaders
const getStyleLoaders = (cssOptions, preProcessor, lessOptions) => {
  const loaders = [
    {
      loader: require.resolve('css-loader'),
      options: cssOptions,
    },
    {
      loader: require.resolve('postcss-loader'),
      options: {
        ident: 'postcss',
        plugins: () => [
          require('postcss-flexbugs-fixes'),
          require('postcss-preset-env')({
            autoprefixer: {
              flexbox: 'no-2009',
            },
            stage: 3,
          }),
          postcssNormalize(),
        ],
        sourceMap: isEnvProduction && shouldUseSourceMap,
      },
    },
  ].filter(Boolean);
  if (preProcessor) {
    if(lessOptions){
      loaders.push(
        {
          loader: require.resolve('resolve-url-loader'),
          options: {
            sourceMap: isEnvProduction && shouldUseSourceMap,
          },
        },
        {
          loader: require.resolve(preProcessor),
          options: {
            sourceMap: true,
            ...lessOptions
          },
        }
      );
    } else {
      loaders.push(
        {
          loader: require.resolve('resolve-url-loader'),
          options: {
            sourceMap: isEnvProduction && shouldUseSourceMap,
          },
        },
        {
          loader: require.resolve(preProcessor),
          options: {
            sourceMap: true,
          },
        }
      );
    }
  }
  return loaders;
};

// 配置 loaders
{
  test: cssRegex,
  exclude: cssModuleRegex,
  use: getStyleLoaders({
    importLoaders: 1,
    sourceMap: isEnvProduction && shouldUseSourceMap,
  }),
  sideEffects: true,
},
{
  test: cssModuleRegex,
  use: getStyleLoaders({
    importLoaders: 1,
    sourceMap: isEnvProduction && shouldUseSourceMap,
    modules: {
      getLocalIdent: getCSSModuleLocalIdent,
    },
  }),
},
{
  test: sassRegex,
  exclude: sassModuleRegex,
  use: getStyleLoaders(
    {
      importLoaders: 3,
      sourceMap: isEnvProduction && shouldUseSourceMap,
    },
    'sass-loader'
  ),
  sideEffects: true,
},
{
  test: sassModuleRegex,
  use: getStyleLoaders(
    {
      importLoaders: 3,
      sourceMap: isEnvProduction && shouldUseSourceMap,
      modules: {
        getLocalIdent: getCSSModuleLocalIdent,
      },
    },
    'sass-loader'
  ),
},
{
  test: lessRegex,
  use: getStyleLoaders(
    {
      importLoaders: 1,
      modules: true
    },
    'less-loader',
    {
      javascriptEnabled: true
    }
  ),
  sideEffects: true,
},
```
压缩代码时，配置是否删除代码中的console.log。提取css到单独文件并压缩时，是否启用sourceMap。
```js
minimizer: [
  new TerserPlugin({
    terserOptions: {
      parse: {
        ecma: 8,
      },
      compress: {
        ecma: 5,
        warnings: false,
        comparisons: false,
        inline: 2,
      },
      mangle: {
        safari10: true,
      },
      keep_classnames: isEnvProductionProfile,
      keep_fnames: isEnvProductionProfile,
      output: {
        ecma: 5,
        comments: false,
        ascii_only: true,
      },
    },
    sourceMap: shouldUseSourceMap,
  }),
  new OptimizeCSSAssetsPlugin({
    cssProcessorOptions: {
      parser: safePostCssParser,
      map: shouldUseSourceMap
        ? {
            inline: false,
            annotation: true,
          }
        : false,
    },
    cssProcessorPluginOptions: {
      preset: ['default', { minifyFontValues: { removeQuotes: false } }],
    },
  }),
],
```
配置js相关loaders，是否启用sourceMap
```js
{
  test: /\.(js|mjs)$/,
  exclude: /@babel(?:\/|\\{1,2})runtime/,
  loader: require.resolve('babel-loader'),
  options: {
    babelrc: false,
    configFile: false,
    compact: false,
    presets: [
      [
        require.resolve('babel-preset-react-app/dependencies'),
        { helpers: true },
      ],
    ],
    cacheDirectory: true,
    cacheCompression: false,
    sourceMaps: shouldUseSourceMap,
    inputSourceMap: shouldUseSourceMap,
  },
},
```
### 热更新和fast-refresh
热更新使你对代码修改并保存后，webpack将会对代码进行打包，并将新的模块发送到浏览器  
fast-refresh是react的最新特性，可以在修改某个模块后只更新改模块的代码，并重新渲染对应的组件  
两者结合后可以实现重模块级到粒度更细的组件级的快速编译转换的能力
引入热更新
```js
isEnvDevelopment &&
  require.resolve('react-dev-utils/webpackHotDevClient'),
```
loader处引入组件级 的 fast-refresh
```js
{
  test: /\.(js|mjs|jsx|ts|tsx)$/,
  include: paths.appSrc,
  loader: require.resolve('babel-loader'),
  options: {
    customize: require.resolve(
      'babel-preset-react-app/webpack-overrides'
    ),
    plugins: [
      [
        require.resolve('babel-plugin-named-asset-import'),
        {
          loaderMap: {
            svg: {
              ReactComponent:
                '@svgr/webpack?-svgo,+titleProp,+ref![path]',
            },
          },
        },
        // loader处引入fast-refresh
        isEnvDevelopment && require.resolve('react-refresh/babel'),
      ].filter(Boolean),
    ],
    cacheDirectory: true,
    cacheCompression: false,
    compact: isEnvProduction,
  },
},
```
处理fast-refresh转换后的文件
```js
isEnvDevelopment && new webpack.HotModuleReplacementPlugin(),
isEnvDevelopment && new ReactRefreshWebpackPlugin({
  overlay: false
}),
```
### 打包文件分块  
splitChunks设置关于打包文件分块的数值  
将依赖的模块分开成数个文件，确保每个文件大小不会过大  
```js
splitChunks: {
  chunks: 'all',
  // name: false,
  maxInitialRequests:8,
  minSize:1000000,
  // maxAsyncRequests:5,
  cacheGroups: {
    vendor: {
      test: /[\\/]node_modules[\\/]/,
      name(module){
        const packageName = module.context.match(/[\\/]node_modules[\\/](.*?)([\\/]|$)/)[1];
        return `npm.${packageName.replace('@', '')}`;
      }
    }
  }
},
```

### 打包文件分析
为了避免重复打包、重复依赖导致发版文件过大，所以引入打包文件分析插件，输出打包后的文件大小及包含各个模块大小。
```js
npm_config_report && new BundleAnalyzerPlugin({
  analyzerMode: 'static',
  reportFilename: 'report.html',
  openAnalyzer: false
}),
```

寻源采用source-map-explorer插件  
通过命令"source-map-explorer 'build/static/js/*.js'"分析打包后的大小
