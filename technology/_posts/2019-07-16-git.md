---
layout: post
title: git
permalink: /technology/git
---
### git的诞生
  1991年，Linus创建了开源的Linux。代码的合入全靠勤劳的双手。随着功能越来越大，社区人越来越多，需要一个版本控制软件。
  Linus坚定地反对CVS和SVN，集中式的版本控制速度慢、依赖网络。好用的又要钱，和Linux的开源精神不符。坚定的不要钱，这一点很不错
  2002年，BitMover公司出于人道主义精神，授权Linux社区免费使用BitKeeper版本控制系统。
  但是总有好事者去破解，BitMover公司不开心了，要收回Linux社区的免费使用权。
  于是Linus花了两周时间自己用C写了一个分布式版本控制系统，这就是Git！一个月之内，Linux系统的源码已经由Git管理了！

### 常用命令
  * git status    查看当前分支状态
  * git reflog  查看之前的事件
  * git diff 文件路径  查看某文件的修改明细
  * git fetch  更新远端更新到本地，不会自动merge
  * git fetch origin branch1   指定更新远端分支branch1，通过这个命令可以来判断远端分支是否还存在
  * git fetch origin branch1:branch2 指定更新远端分支branch1并合并到本地分branch2，本地如果不存在branch2分支，将会自动创建一个。若遇到冲突合并将会停止
  * git pull    更新代码，相当于fetch之后自动merge
  * git commit    提交代码
  * git commit --amend 修改最近一次提交(不要在推送之后去修改)
  * git push    将代码提交至远端
  * git push origin <name> 将指定标签推送至远程库
  * git push origin :<name> 将远程库中指定标签删除
  * git branch    查看本地分支
  * git remote show origin  查看远端分支信息
  * git remote prune origin 清除远端已经不存在的分支
  * git checkout    切换至新分支
  * git checkout -b origin/<branch> <branch>    切换至新分支并连接到某远端分支
  * git checkout --track origin/<branch> 与上面作用相同，需要git 1.6.2版本以上
  * git branch -d branch_name 删除一个分支
  * git branch -D branch_name 强制删除一个分支
  * git merge branch_name    将某分支合并至当前分支
  * git branch --set-upstream-to=origin/<branch> <branch>    将本地分支连接至远端分支
  * git config 可设定命令的快捷键。git config --global alias.co checkout将checkout快捷键设置为co
  * git stash  存储当前变动
  * git stash -u /git stash --include-untracked 存储当前变动，并且包含新增的文件
  * git stash list 查看全部的存储列表
  * git stash clear 清除全部的存储
  * git stash apply <stash> 将某一条存储应用到当前工作区
  * git stash apply --index 将某一条存储应用到当前工作区，并且保存之前已经暂存的状态
  * git stash drop <stash> 删除某一条存储
  * git stash pop <stash> 应用某一条存储到当前工作区，并且删除这条存储(在应用的时候遇到冲突，这条存储将不会被删除)
  * git stash branch <branchname> <stash> 以某一条存储当时的状态新建一条分支

### git config
  * 通过修改config来为完整的命令设置快捷键
  * $ git config --global alias.co checkout
  * $ git config --global alias.br branch
  * $ git config --global alias.ci commit
  * $ git config --global alias.st status

### tag操作
  * git tag <name>即可创建标签
  * git tag 查看已经创建的标签
  * git tag <name> <commitID>可以对历史某个commit打上标签（多个标签排序是根据字母排序的）
  * git tag -a <name> -m "<des msg>" <commitID> 打标签的参数，-a后面接名字，-m后面是描述
  * git -s 可以用私钥签名一个标签，采用PGP签名，若未安装gpg（GnuPG）则会报错。
  * git tag -d <name>删除一个标签
  * git tag -l “v1.4.2.* ” 查看所有的tag，引号中的内容可作为搜索条件
  * git push origin --tags 将本地未推送过的标签一并推送至远程库
  * git show <name>查看指定标签的信息内容
  * git checkout <name> 取得对应标签的代码。此时tag想到于一个快照，无法更改其中的代码。可以理解为当前处在一个空的分支上
  * git checkout -b <branch_name> <tag_name> 从指定的标签中切出一个新的分支，这种情况下是可以更改代码的
  * 这里标签的变动与文件不同，文件的删除当做一个修改，而标签的删除若不推送至远端，更新之后tag会再次出现

### 分支的衍合
  * git rebase <main_branch> <feature_branch> 该命令会先取出特性分支，再主干分支上重演。
  * 衍合的效果可以简化提交历史，看起来完全只有一个分支的发展。相当于省去了各种各样的merge。
  * 但是注意一点，这些事儿只能在你本地做，虽然rebase之后的代码是完整的，但是rebase前后的commit是完全不同的。如果你之前已经将代码推送至了远端，再进行rebase操作，那么结果就是所有人的commit将会一团糟

### git 版本管理
  版本管理的意义：
  项目随着开发的进行，我们希望能在任何时候回到任何一个版本。以解决现有的问题。
  于是出现了最原始的本地版本控制。
  把整个项目复制多份，并且以时间命名，这样我们就能找到过去某个时间的项目代码。
  明显这样很痛苦，目录复杂，并且一旦出现错误很难挽回。容错率很低。
  于是我们升级一下：Centralized Version Control Systems，简称CVCS —— 集中式版本控制(如SVN)
  版本库放在服务器上，每个开发者都有权限更新与提交。也方便管控权限。
  开发之前记得更新，也能看到其他的开发者在做些什么。
  缺陷也很明显，一旦服务器跪了，或者服务器数据丢失，就特喵的竹篮打水一场空了。
  于是我们再升级一下：Distributed Version Control System，简称 DVCS —— 分布式版本控制系统(如git)
  每个客户端除了版本快照之外，还获取了整个项目的代码文件。就算服务器跪了，任何开发者的客户端上都可以取到完整的代码
  相比之前的版本管理系统Git的优势
  1、Git 并不保存文件前后变化的差异数据。实际上，Git 更像是把变化的文件作快照后，记录在一个微型的文件系统中。每次提交更新时，它会纵览所有文件的指纹信息并对文件作快照，然后保存指向这次快照的索引。为提高性能，若文件没有变化，Git 不会再次保存，而只对上次保存的快照作链接
  2、Git的操作都在本地。速度极快且无需网络支持。只有push的时候才需要网络。比如查看历史log，对比以前的文件差异，git都是在本地的版本库中读取记录。

### 服务器上的Git
  * git主要使用四种协议来传输：本地传输、SSH协议、Git协议与HTTP协议
  * 本地协议就是硬盘上的另一个目录。
    优点：方式简单，而且相互checkout分支都很方便。相对从服务器上的代码库中操作要简单的多。
    缺点：这种情况并不安全，所有代码都存在同一块硬盘中，增加了容灾风险。
  * SSH协议
    优点：普遍性、架设与使用都相对简单。加密传输、高效传输(传输之前会尽量压缩数据)
    缺点：SSH无法实现匿名访问仓库
  * Git协议
    优点：这是所有协议中最快的一种。与SSH相同的数据传输机制。并且没有加密与授权的消耗
    缺点：没有授权机制。
  * HTTP/S协议
    优点：易于架设，支持高并发，耗资源少。适用性高，企业级防火墙也允许其端口通信。
    缺点：客户端效率低。传输体积与网络开销两方面，比其他所有协议都要差。

### 分布式工作流程
  * 集中式工作流
  * 单点协作、存放仓库的中心服务器。所有人都往一个远端仓库提交
  * 集成管理员工作流
  * 每个开发者有自己的远端仓库，向自己的远端仓库推送。然后申请合入主干。
  * 管理者可以在自己的本地将远端仓库更新下来测试，没有问题之后就合入主干。
  * 这才是我们应有的方式。这一步有管理员把关，可加入代码检视的步骤。
  * 司令官与副官的工作流
  * 属于管理员工作流的变种。只有超大项目才会使用这种方式管理如Linux内核项目。
  * 管理员分级管理，总司令只分管自己的副官(小组长)，每个小组长再管理自己组内的开发者。
  * 这种方式项目的总负责人分散给不同的小组负责人。最终来统筹。各责任人职责清晰，也不易出错。

###  Git工具 - 重写
  * 修改commit信息
  * git commit --amend可以修改最近一次提交的信息。
  * git rebase -i 的方式运行rebase。通过这种方式可以衍合提交
  * 修改多次提交的说明：
  * git rebase -i HEAD~3 数字代表往前几次的commit，注意这里并不是从0开始数的
  * 输入命令之后，会进入编辑器，并且有相关命令提示；
  * 注意这里的顺序与查看Log时候
  * 在编辑器中，修改需要的命令，保存退出时git将会按照顺序执行脚本
  * 执行完毕之后，将会看到提示，通过--amend与 rebase --continue完成commit的修改
  * 重排提交：
  * rebase之后，使用squash命令，会将squash的提交归并到一次提交中
  * 之后Git会合并三次的提交说明，在这一步骤中可以修改commit信息。完成编辑之后之前的多次提交就会合并为一个
  * 拆分提交：
  * 同样是rebase开头，选中某一次commit之后，在编辑器中输入edit此次commit
  * 退出编辑器后，rebase执行中直接reset，之后按照正常流程将工作区的文件分别提交，录入commit信息。完成rebase即可完成拆分提交
